%YAML 1.2
---
title: "Add With Carry"
validity: "1632,64"
opcode:
  - opcode: "14 ib"
    mnemonic: "ADC AL, imm8"
    encoding: "I"
    validity:
      1632: "valid"
      64: "valid"
    description: "Add with carry imm8 to AL."
  - opcode: "15 iw"
    mnemonic: "ADC AX, imm16"
    encoding: "I"
    validity:
      1632: "valid"
      64: "valid"
    description: "Add with carry imm16 to AX."
  - opcode: "15 id"
    mnemonic: "ADC EAX, imm32"
    encoding: "I"
    validity:
      1632: "valid"
      64: "valid"
    description: "Add with carry imm32 to EAX."
  - opcode: "REX.W 15 id"
    mnemonic: "ADC RAX, imm32"
    encoding: "I"
    validity:
      1632: "n/e"
      64: "valid"
    description: "Add with carry imm32 sign extended to 64 bits to RAX"
  - opcode: "80 /2 ib"
    mnemonic: "ADC r/m8, imm8"
    encoding: "MI"
    validity:
      1632: "valid"
      64: "valid"
    description: "Add with carry imm8 to r/m8."
  - opcode: "REX 80 /2 ib"
    mnemonic: "ADC r/m8*, imm8"
    encoding: "MI"
    validity:
      1632: "n/e"
      64: "valid"
    description: "Add with carry imm8 to r/m8."
  - opcode: "81 /2 iw"
    mnemonic: "ADC r/m16, imm16"
    encoding: "MI"
    validity:
      1632: "valid"
      64: "valid"
    description: "Add with carry imm16 to r/m16."
  - opcode: "81 /2 id"
    mnemonic: "ADC r/m32, imm32"
    encoding: "MI"
    validity:
      1632: "valid"
      64: "valid"
    # Intel's manual (v73) uses "CF"
    description: "Add with carry imm32 to r/m32."
  - opcode: "REX.W 81 /2 id"
    mnemonic: "ADC r/m64, imm32"
    encoding: "MI"
    validity:
      1632: "n/e"
      64: "valid"
    # Intel's manual (v73) uses "CF"
    description: "Add with carry imm32 sign extended to 64 bits too r/m64."
  - opcode: "83 /2 ib"
    mnemonic: "ADC r/m16, imm8"
    encoding: "MI"
    validity:
      1632: "valid"
      64: "valid"
    # Intel's manual (v73) uses "CF" and "sign extended imm8"
    description: "Add with carry imm8 sign extended to 16 bits to r/m16."
  - opcode: "83 /2 ib"
    mnemonic: "ADC r/m32, imm8"
    encoding: "MI"
    validity:
      1632: "valid"
      64: "valid"
    # Intel's manual (v73) uses "CF" and "sign extended imm8"
    description: "Add with carry imm8 sign extended to 32 bits to r/m32."
  - opcode: "REX.W 83 /2 ib"
    mnemonic: "ADC r/m64, imm8"
    encoding: "MI"
    validity:
      1632: "n/e"
      64: "valid"
    # Intel's manual (v73) uses "CF" and "sign extended imm8"
    description: "Add with carry imm8 sign extended to 64 bits to r/m64."
  - opcode: "10 /r"
    mnemonic: "ADC r/m8, r8"
    encoding: "MR"
    validity:
      1632: "valid"
      64: "valid"
    # Intel's manual (v73) uses "byte register"
    description: "Add with carry r8 to r/m8."
  - opcode: "REX 10 /r"
    mnemonic: "ADC r/m8*, r8*"
    encoding: "MR"
    validity:
      1632: "n/e"
      64: "valid"
    # Intel's manual (v73) uses "byte register"
    description: "Add with carry r8 to r/m8."
  - opcode: "11 /r"
    mnemonic: "ADC r/m16, r16"
    encoding: "MR"
    validity:
      1632: "valid"
      64: "valid"
    description: "Add with carry r16 to r/m16."
  - opcode: "11 /r"
    mnemonic: "ADC r/m32, r32"
    encoding: "MR"
    validity:
      1632: "valid"
      64: "valid"
    # Intel's manual (v73) uses "CF"
    description: "Add with carry r32 to r/m32."
  - opcode: "REX.W 11 /r"
    mnemonic: "ADC r/m64, r64"
    encoding: "MR"
    validity:
      1632: "n/e"
      64: "valid"
    # Intel's manual (v73) uses "CF"
    description: "Add with carry r64 to r/m64."
  - opcode: "12 /r"
    mnemonic: "ADC r8, r/m8"
    encoding: "RM"
    validity:
      1632: "valid"
      64: "valid"
    # Intel's manual (v73) uses "byte register"
    description: "Add with carry r/m8 to r8."
  - opcode: "REX 12 /r"
    mnemonic: "ADC r8*, r/m8*"
    encoding: "RM"
    validity:
      1632: "n/e"
      64: "valid"
    # Intel's manual (v73) uses "r/m64" and "byte register"
    description: "Add with carry r/m8 to r8."
  - opcode: "13 /r"
    mnemonic: "ADC r16, r/m16"
    encoding: "RM"
    validity:
      1632: "valid"
      64: "valid"
    description: "Add with carry r/m16 to r16."
  - opcode: "13 /r"
    mnemonic: "ADC r32, r/m32"
    encoding: "RM"
    validity:
      1632: "valid"
      64: "valid"
    # Intel's manual (v73) uses "CF"
    description: "Add with carry r/m32 to r32."
  - opcode: "REX.W 13 /r"
    mnemonic: "ADC r64, r/m64"
    encoding: "RM"
    validity:
      1632: "n/e"
      64: "valid"
    # Intel's manual (v73) uses "CF"
    description: "Add with carry r/m64 to r64."
encoding:
  - encoding: "I"
    op1: "AL/AX/EAX/RAX"
    op2: "imm8/16/32"
    op3: "N/A"
    op4: "N/A"
  - encoding: "MI"
    op1: "ModRM:r/m[rw]"
    op2: "imm8/16/32"
    op3: "N/A"
    op4: "N/A"
  - encoding: "MR"
    op1: "ModRM:r/m[rw]"
    op2: "ModRM:reg[r]"
    op3: "N/A"
    op4: "N/A"
  - encoding: "RM"
    op1: "ModRM:reg[rw]"
    op2: "ModRM:r/m[r]"
    op3: "N/A"
    op4: "N/A"
description: >-
  Adds the destination operand (first operand), the source operand (second operand), and the carry (CF) flag and stores the result in the destination operand.
  The destination operand can be a register or a memory location;
  The source operand can be an immediate, a register, or a memory location.
  (However, two memory operands cannot be used in one instruction.)
  The state of the CF flag represents a state from a previous addition.
  When an immediate value is used as an operand, it is sign extended to the length of the destination operand format.

  The ADC instruction does not distinguish between signed and unsigned operands.
  Instead, the processor evaluates the result for both data types and sets the OF and CF flags to indicate a carry in the signed or unsigned result, respectively.
  The SF flag indicates the sign of a signed result.

  The ADC instruction is usually executed as part of a multibyte or multiword addition in which an ADD instruction is followed by an ADC instruction.

  This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.

  In 64-bit mode, the instruction's default operand size is 32 bits.
  Using the REX prefix in the form of REX.R permits access to addition registers (R8-R15).
  Using a REX prefix in the form of REX.W promotes operation to 64 bits.
  See the summary chart at the beginning of this section for encoding data and limits.
operation: >-
  fn adc<D, S>(dest: D, src: S) {
    dest = dest + src + CF;
  }
flags: >-
  The OF, SF, ZF, CF, and PF flags are set according to the result.
intrinsicsC:
  - "uint8_t _addcarry_u8(uint8_t c_in, uint8_t src1, uint8_t src2, uint8_t *sum_out)"
  - "uint8_t _addcarry_u16(uint8_t c_in, uint16_t src1, uint16_t src2, uint16_t *sum_out)"
  - "uint8_t _addcarry_u32(uint8_t c_in, uint32_t src1, uint32_t src2, uint32_t *sum_out)"
  - "uint8_t _addcarry_u64(uint8_t c_in, uint64_t src1, uint64_t src2, uint64_t *sum_out)"
intrinsicsRust:
  - "addcarry::u8(c: u8, src1: u8, src2: u8, sum: &mut [u8]) -> u8"
  - "addcarry::u16(c: u8, src1: u16, src2: u16, sum: &mut [u16]) -> u8"
  - "addcarry::u32(c: u8, src1: u32, src2: u32, sum: &mut [u32]) -> u8"
  - "addcarry::u64(c: u8, src1: u64, src2: u64, sum: &mut [u64]) -> u8"
exceptions:
  protected:
    "#GP(0)":
      - "If the destination is located in a non-writable segment."
      - "If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit."
      - "If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector."
    "#SS(0)": "If a memory operand effective address is outside the SS segment limit."
    "#PF(fault-code)": "If a page fault occurs."
    "#AC(0)": "If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3."
    "#UD": "If the LOCK prefix is used but the destination is not a memory operand."
  real:
    "#GP": "If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit."
    "#SS": "If a memory operand effective address is outside the SS segment limit."
    "#UD": "If the LOCK prefix is used but the destination is not a memory operand."
  virtual:
    "#GP(0)": "If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit."
    "#SS(0)": "If a memory operand effective address is outside the SS segment limit."
    "#PF(fault-code)": "If a page fault occurs."
    "#AC(0)": "If alignment checking is enabled and an unaligned memory reference is made."
    "#UD": "If the LOCK prefix is used but the destination is not a memory operand."
  compatibility: "Same exceptions as in protected mode."
  long:
    "#SS(0)": "If a memory address referencing the SS segment is in a non-canonical form."
    "#GP(0)": "If a memory operand address is in a non-canonical form."
    "#PF(fault-code)": "If a page fault occurs."
    "#AC(0)": "If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3."
    "#UD": "If the LOCK prefix is used but the destination is not a memory operand."
