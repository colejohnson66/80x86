%YAML 1.2
---
title: "Unsigned Integer Addition of Two Operands with Carry Flag"
validity: "32,64"
opcode:
  - opcode: "66 0F 38 F6 /r"
    mnemonic: "ADCX r32, r/m32"
    encoding: "RM"
    validity:
      32: "valid"
      64: "valid"
    cpuid: "ADX"
    description: "Unsigned addition of r32 with carry flag and r/m32 to r32. Writes carry flag."
  - opcode: "66 REX.W 0F 38 F6 /r"
    mnemonic: "ADCX r64, r/m64"
    encoding: "RM"
    validity:
      32: "n/e"
      64: "valid"
    cpuid: "ADX"
    description: "Unsigned addition of r64 with carry flag and r/m64 to r64. Writes carry flag."
encoding:
  operands: 2
  encodings:
    RM:
      - "ModRM:reg[rw]"
      - "ModRM:r/w[r]"
description: >-
  Performs an unsigned addition of the destination operand (first operand), the source operand (second operand), and the carry flag (CF) and stores the result in the destination operand.
  The destination operand can be a general purpose register or memory location.
  The state of CF can represent a carry from a previous addition.
  The instruction sets the CF flag with the carry generated by the unsigned addition of the operands.

  The ADCX instruction is executed in the context of multi-precision addition, where we add a series of operands with a carry-chain.
  At the beginning of a chain of additions, we need to make sure the CF is in a desired initial state.
  Often, this state needs to be 0, which can be achieved with an instruction to zero the CF (eg. XOR).

  This instruction is supported in real and virtual-8086 mode.
  The operand size is always 32 bits if not in 64 bit mode.

  In 64 bit mode, the default operation size is 32 bits.
  Using a REX prefix in the form of REX.R permits access to addition registers (R8-R15).
  Using a REX prefix in the form of REX.W promotes operation to 64 bits.

  ADCX executes normally either inside or outside a transactional region.

  Note: ADCX defines the OF flag differently than the ADD/ADC instructions.
operation: >-
  fn adcx<D, S>(dest: D, src: S) {
    dest = dest + src + CF;
    setCF(dest);
  }
flags: >-
  CF is updated based on the result. OF, SF, ZF, AF, and PF flags are unmodified.
intrinsicsC:
  - "uint8_t _addcarryx_u32(uint8_t c_in, uint32_t src1, uint32_t src2, uint32_t *sum_out)"
  - "uint8_t _addcarryx_u64(uint8_t c_in, uint64_t src1, uint64_t src2, uint64_t *sum_out)"
intrinsicsRust:
  - "addcarryx::u32(c: u8, src1: u32, src2: u32, sum: &mut [u32]) -> u8"
  - "addcarryx::u64(c: u8, src1: u64, src2: u64, sum: &mut [u64]) -> u8"
exceptions:
  protected:
    "#UD":
      - "If the LOCK prefix is used."
      - "If CPUID[EAX=07,ECX=0]:EBX.ADX[19] is 0."
    "#SS(0)": "For an illegal address in the SS segment."
    "#GP(0)":
      - "For an illegal memory operand effective address in the CS, DS, ES, FS, or GS segments."
      - "If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector."
    "#PF(fault-code)": "If a page fault occurs."
    "#AC(0)": "If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3."
  real:
    "#UD":
      - "If the LOCK prefix is used."
      - "If CPUID[EAX=07,ECX=0]:EBX.ADX[19] is 0."
    "#SS(0)": "For an illegal address in the SS segment."
    "#GP(0)": "If any part of the operand lies outside the effective address space from 0 to 0xFFFF."
  virtual:
    "#UD":
      - "If the LOCK prefix is used."
      - "If CPUID[EAX=07,ECX=0]:EBX.ADX[19] is 0."
    "#SS(0)": "For an illegal address in the SS segment."
    "#GP(0)": "If any part of the operand lies outside the effective address space from 0 to 0xFFFF."
    "#PF(fault-code)": "If a page fault occurs."
    "#AC(0)": "If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3."
  compatibility: "Same exceptions as in protected mode."
  long:
    "#UD":
      - "If the LOCK prefix is used."
      - "If CPUID[EAX=07,ECX=0]:EBX.ADX[19] is 0."
    "#SS(0)": "If a memory address referencing the SS segment is in non-canonical form."
    "#GP(0)": "If the memory address is in a non-canonical form."
    "#PF(fault-code)": "If a page fault occurs."
    "#AC(0)": "If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3."
changes:
  version: 73
  date: "2020-11"
  list:
    - "In the overview table, both description cells use '...with CF and...'. This has been changed to '...with carry flag and...'."
